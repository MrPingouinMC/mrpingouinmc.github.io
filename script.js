
/*
    This script only support commands generated by a "one command generator"
    Can't predic the result if the command is invalid
    This generator can only seak numbers or string with a key
    
    */

var optionsGlobal = {};
	
var cmdVersion = 50;
var fixVersion = 900;

    

function tester(){
	var cmdVersion = 1000;
	dataFixer();
	var cmdVersion = 50;
}
	
    
function dataFixer(){
    clearError("areaIn");
    var commands = document.getElementById("areaIn").value.split("\n");
    optionsGlobal = parseOptions(document.getElementById("globalOption"));    

    var output = [];
    
    for(var i = 0; i < commands.length; i++){
        commands[i] = commands[i].trim();
        if(commands[i] == "" || commands[i].startsWith("#") || commands[i] == "/"){
            continue;
        }
        try{
			//TODO maybe detect a raw nbt or json (then how to differentiate between item/entity/block).
            fixedCmd = process("command", commands[i])
        }catch(error){
            setError("areaIn", error);
            document.getElementById("areaOut").value = "";
            return null;
        }
        output.push(fixedCmd);
    }
    
    document.getElementById("areaOut").value = output.join("\n");
    
    focusAreaByName("areaOut");
}

function clearError(nodeId){
    var node = document.getElementById(nodeId);
    node.classList.remove("script-error");
    node.removeAttribute("title");
}

function setError(nodeId, error){
    var node = document.getElementById(nodeId);
    node.classList.add("script-error");
    node.setAttribute("title", "Error " + error);
    console.log(error);
}


function parseOptions(node){
    var optionObj = {};
    var options = node.getElementsByClassName("cmd-option");
   
    for(var i = 0; i < options.length; i++){
        var currentOption = options[i];
        optionObj[currentOption.getAttribute("var-name")] = getOptionValue(currentOption);
    }
    return optionObj;
}

function getOptionValue(option){
    var tag = option.tagName.toLowerCase();
    if(tag == "select"){
        return option.value;
    }else if(tag == "textarea"){
        return option.value
    }else if(tag == "input"){
        var type = option.getAttribute("type");    
        if(type == "text"){
            return option.value;
        }else if(type == "checkbox"){
            return option.checked;
        }else{
            console.log("Unsupported option type : " + type);
        }
    }else{
        console.log("Unsupported tag name : " + tag);
    }

}


function focusAreaByName(areaId){
    focusArea(document.getElementById(areaId));
}

function focusArea(area){
    area.focus();
    area.select();
}

function initDataFixer(){
    for(var i in fixType){
        var type = fixType[i];
		datafixes[type] = [];
        dataWalkers[type] = [];
    }
    registerDataFixes();
    registerWalkers();
}

initDataFixer();